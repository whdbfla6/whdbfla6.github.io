---
title: "[Information retrieval]GETTING BEYOND BOOLE 논문 요약"
use_math: true
comments: true
layout: single
categories:
  - Information retrieval
---





본 글은 문성빈 교수님의 <정보검색론>수업 때 과제로 진행한 [GETTING BEYOND BOOLE] 논문 요약 내용입니다

> 서론

search requests를 문서 descriptor의 불리언 조합으로 사용하는 것은 정보검색의 도구로서 컴퓨터가 대두되는 시기에 처음 제안되었다. 실제 검색전략으로 불리언 접근을 사용한 것은 도서 목록 검색 시스템이 구축되는 시점이었으며, 이후의 상용화된 검색 서비스에도 적용되었다. 오늘날의 검색시스템에서 불리언 request form은 아주 흔한 방식이며, 정보 검색 분야 전문가의 적극적인 지지를 얻지 못하는 상황이다. 그러나 불리언 방식을 대체할만한 좋은 대안이 없어 여전히 불리언 방식을 고수하고 있다. 이 논문에서는 불리언 로직이 갖고있는 특정한 문제점 및 이를 개선할 수 있는 해결책을 제시하고 있다. 

> 문제1 : 불리언 공식의 불친절함

검색모형으로 불리언 연산자를 맨 처음 제안한 사람들은 불리언 로직에 익숙한  컴퓨터나 수학 전공자들이었을 것이다. 하지만 lay users(특정 전문분야에 대한 지식이 없는 이용자로 professional user의 반대말이다)에게 불리언 request form은 적절하지 못하다는 평가를 받는다. 일상생활에서 "A AND B"라는 어구는 A 하나를 사용할 때보다 더 많은 요소를 포함하는 방식으로 해석된다. 하지만 정보 검색에서는 A 하나만을 검색할 때보다 A AND B는 더 좁은 범위를 나타낸다. 즉 일상생활에서의  AND OR의 해석과 정보검색에서의 논리 접근 방식에는 차이가 있기 때문에 일반적인 USER에게는 혼란을 줄 수 있다. 비록 이용자들이 불리언 연산자의 의미를 올바르게 이해했더라도 연산자들을 매칭하기 위한 삽입어구, 범위 문제 등에 대한 실질적 연습을 위해 많은 시간을 할애해야 한다.

> 문제1 solution : symbol-free faceted requests

이용자들은 불리언 검색 시스템의 연습 단계에서 search term의 리스트 혹은 facet을 작성한다. 그 후에 유사어나 개념 클러스터의 리스트들을 OR이나 AND에 연산자로 연결해 Boolean request 형식으로 바꾸는 작업을 진행한다. 예를들어 3개의 개념 클러스터 (1) A B (2) C (3) D E F G 작성 후에 (A OR B) AND C AND (D OR E OR F OR G)와 같이 불리언 형식으로 바꾸는 것이다. 하지만 faceted reqeust form이 오직 불리언 형식이라면 이용자는 더이상 boolean 연산을 학습할 필요가 없어진다. 이용자들은 그저 그들의 아이디어와, 유사 동이어 리스트를 구성해 어떻게 정보를 기술할 것인지의 한 두가지의 예시만 제공하면 컴퓨터가 자동적으로 faceted 불리언 형태로 변환해 줄 것이다. 

> 문제2 : NULL output and output overload

전통적인 서지학 검색 시스템에서 3개 혹은 4개의 facet들을 AND 연산자로 연결해 검색하는 과정에서 NULL값이 나오는 문제점이 발생하였다. 이용자들은 주로 한개 이상의 기존 Facet들을 제거하면서 문제를 해결했지만, 수많은 절단 과정 속에서 많은 시간이 소요된다는 문제를 낳았다. 또한 facet을 제거하는 과정에서 기존의 request가 저하된다는 문제가 있었다. 반대로 검색 결과가 너무 많아서 이용자들이 갈 길을 잃어버리는 상황이 발생하기도 한다. 이 경우에 이용자들에게 검색된 문헌들 중 어떤 부분이 관련성이 있는지 정보를 제공해 줌으로써 문제를 완화시킬 수 있으나, 불리언 검색에서는 불가능하다. 

> 문제2 solution : ranking by coordination level

만약 불리언 request가 facted form으로 시스템에 입력되었다면, 결과물은 만족하는 facet의 수에 따라 순차적으로 출력될 수 있을 것이다. 모든 facet을 만족하는 경우에 상단에 위치할 것이고, 하나를 제외하고 만족하는 경우 두번째에 위치할 것이다. 이러한 방식에서는 null값이 출력되지 않으며, 관련 있는 정보가 상단에 노출되면서 이용자들은 만족할 정보를 찾을 때까지 자료들을 살펴볼 것이다. 이러한 ranking system은 모든 facet이 동일한 가중치를 갖는다는 가정을 두고 있다. 

> 문제3 : 차별되지 않는 facets

이용자들은 검색어에서 특정 facet에 더 높은 가중치를 두고 싶을 것이다. 하지만 전통적인 불리언 시스템에서는 이러한 의사를 시스템에 전달해 줄 방법이 없다. 

> 문제3 solution : weighted request term 

facet들이 시스템에 입력이 된다면 이용자들에게 각각의 가중치를 매기도록 요구함으로써 문제를 해결할 수 있다. 높은 가중치는 이용자에게 주관적으로 높은 중요도를 나타내며, 검색결과는 만족되는 facet의 수와 가중치가 모두 고려된 결과물이다. 예를들어 (A OR B) AND C 두개의 facet이 있을 때 (A OR B)와 C 각각의 가중치가 3 5라고 하자. (A OR B) AND C를 만족하는 문서가 가중치 8로 가장 상단에 출력될 것이며, (A OR B)는 만족하지 못하지만 C에 적합되는 문서를 그 다음으로 얻을 수 있을 것이다. NOT으로 연렬되는 facet들은 음수의 가중치 값을 가질 것이다. 하지만 이러한 가중치 부여 방식이 실제 시스템에 많이 적용되지 않아 이용자들이 이를 어떻게 받아들일지는 미지수다. 따라서 facet들이 모두 동일한 가중치 값을 갖는것을 default로 하여 선택적으로 이용자들이 가중치 값을 조정하도록 할 수 있다. 혹은 이용자에게 실제 숫자를 부여하도록 요구하는 것이 아니라 리스트를 중요한 순으로 배치하도록 하여 시스템이 자동적으로 높은 순위의 단어에 높은 가중치를 부여할 수도 있을 것이다. 위 방법들 외에도 weigted indexing 방식 또한 가능하다. index term은 해당 문서에 등장한 단어의 수를 기반으로 각각의 문서에 가중치를 부여하는 방식이다. 

> 문제4 : interpreting the weights

검색어에 가중치를 부여하는 방식에서 가중치를 어떻게 해석할 것인지가 중요한 문제로 자리잡고 있다. 단순히 필요한 정보에 대한 facet의 상대적인 중요성으로 해석하는 것은 부적절하다. 중요도의 의미를 규명하고 본인의 생각을 수량한다는 것이 쉽지 않기 때문이다.

> 문제4 해결책 : The probabilistic interpretation 

통계를 기반으로한 검색 모형 중 하나인 probability ranking principle은 search query의 결과물을 유용성의 확률을 근거로 내림차순으로 배치한다. 즉 term request의 facet 가중치는 확률론적 해석이 주어져야 한다. 예를들어 이용자가 T 용어에 W의 가중치를 주었다고 하자. W는 T가 포함된 문서가 정보 요구와 관련있을 확률을 이용자가 주관적으로 추정한 것이다. 이용자들은 descriptor T를 포함하고 있는 문서의 집합과 그 중에서 유용할만한 문서의 비율을 상상할 것이다. 가중치가 확률론적으로 해석된다면, 프로그램 또한 각 문헌들의 유용성에 대한 확률을 추정하는 방식으로 바꿀 수 있을 것이다. 이는 추정된 확률이 특정 임계치 이상인 결과물들만 보여주고, 추정된 확률에 따라서 내림차순으로 배열하는 방식이다. 이용자들이 확률을 부여하는데 있어 검색어를 포함하고 있는 문헌 집합의 수와 이전의 데이터를 통해 해당 검색어로 정의된 size 중에 유용하다고 판단된 문헌의 비율을 사전에 제공한다면 의사결정에 도움을 줄 수 있을 것이다. 이용자가 확률을 부여하지 않는다면 구체적인 request term에 높은 가중치를 부여하고 포괄적인 request term에 낮은 가중치를 자동적으로 부여함으로써 좋은 성능을 보일 수 있다. 

> 문제5 및 해결책 : Term dependencies & advanced statistical techniques 

Robertson과 spack Jones에 의해 제안된 확률론적 검색 공식은 문헌 집단 안에서 index term들이 독립이라는 가정을 두고 있다. 하지만 확률론적 검색 시스템은 단어들이 서로 의존적이라는 가정 아래 더 좋은 성능을 보일 것이다.
단어들 간의 의존성을 고려하기 위해 제안된 하나의 방법은 maximum entropy이다. 이는 독립성 가정을 제거하고 어떠한 확률론적 데이터나 제약을 이용 가능하게 해준다. 이 방법은 dependency problem을 해결해주기는 하지만 컴퓨팅적으로 실현 가능한지 명확하지는 않기 때문에 계속적으로 연구해나가야 하는 문제다. 

[논문 원문 링크](https://www.sciencedirect.com/science/article/abs/pii/030645738890091X)
